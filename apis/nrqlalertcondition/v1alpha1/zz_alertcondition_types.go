/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AlertConditionObservation struct {

	// The unique entity identifier of the NRQL Condition in New Relic.
	EntityGUID *string `json:"entityGuid,omitempty" tf:"entity_guid,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AlertConditionParameters struct {

	// The New Relic account ID for managing your NRQL alert conditions.
	// +kubebuilder:validation:Optional
	AccountID *float64 `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use aggregationDelay with the EVENT_FLOW and CADENCE aggregation methods.
	// +kubebuilder:validation:Optional
	AggregationDelay *string `json:"aggregationDelay,omitempty" tf:"aggregation_delay,omitempty"`

	// The method that determines when we consider an aggregation window to be complete so that we can evaluate the signal for violations. Default is EVENT_FLOW.
	// +kubebuilder:validation:Optional
	AggregationMethod *string `json:"aggregationMethod,omitempty" tf:"aggregation_method,omitempty"`

	// How long we wait after each data point arrives to make sure we've processed the whole batch. Use aggregationTimer with the EVENT_TIMER aggregation method.
	// +kubebuilder:validation:Optional
	AggregationTimer *string `json:"aggregationTimer,omitempty" tf:"aggregation_timer,omitempty"`

	// The duration of the time window used to evaluate the NRQL query, in seconds.
	// +kubebuilder:validation:Optional
	AggregationWindow *float64 `json:"aggregationWindow,omitempty" tf:"aggregation_window,omitempty"`

	// The baseline direction of a baseline NRQL alert condition. Valid values are: 'LOWER_ONLY', 'UPPER_AND_LOWER', 'UPPER_ONLY' (case insensitive).
	// +kubebuilder:validation:Optional
	BaselineDirection *string `json:"baselineDirection,omitempty" tf:"baseline_direction,omitempty"`

	// Whether to close all open violations when the signal expires.
	// +kubebuilder:validation:Optional
	CloseViolationsOnExpiration *bool `json:"closeViolationsOnExpiration,omitempty" tf:"close_violations_on_expiration,omitempty"`

	// A condition term with priority set to critical.
	// +kubebuilder:validation:Optional
	Critical []CriticalParameters `json:"critical,omitempty" tf:"critical,omitempty"`

	// The description of the NRQL alert condition.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Whether or not to enable the alert condition.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The amount of time (in seconds) to wait before considering the signal expired.  Must be in the range of 30 to 172800 (inclusive)
	// +kubebuilder:validation:Optional
	ExpirationDuration *float64 `json:"expirationDuration,omitempty" tf:"expiration_duration,omitempty"`

	// Which strategy to use when filling gaps in the signal. If static, the 'fill value' will be used for filling gaps in the signal. Valid values are: 'NONE', 'LAST_VALUE', or 'STATIC' (case insensitive).
	// +kubebuilder:validation:Optional
	FillOption *string `json:"fillOption,omitempty" tf:"fill_option,omitempty"`

	// If using the 'static' fill option, this value will be used for filling gaps in the signal.
	// +kubebuilder:validation:Optional
	FillValue *float64 `json:"fillValue,omitempty" tf:"fill_value,omitempty"`

	// The title of the condition.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// A NRQL query.
	// +kubebuilder:validation:Required
	Nrql []NrqlParameters `json:"nrql" tf:"nrql,omitempty"`

	// Whether to create a new violation to capture that the signal expired.
	// +kubebuilder:validation:Optional
	OpenViolationOnExpiration *bool `json:"openViolationOnExpiration,omitempty" tf:"open_violation_on_expiration,omitempty"`

	// The ID of the policy where this condition should be used.
	// +kubebuilder:validation:Required
	PolicyID *float64 `json:"policyId" tf:"policy_id,omitempty"`

	// Runbook URL to display in notifications.
	// +kubebuilder:validation:Optional
	RunbookURL *string `json:"runbookUrl,omitempty" tf:"runbook_url,omitempty"`

	// The duration of overlapping timewindows used to smooth the chart line, in seconds. Must be a factor of `aggregation_window` and less than the aggregation window. It should be greater or equal to 30 seconds if `aggregation_window` is less than or equal to 3600 seconds, or greater or equal to `aggregation_window / 120` if `aggregation_window` is greater than 3600 seconds.
	// +kubebuilder:validation:Optional
	SlideBy *float64 `json:"slideBy,omitempty" tf:"slide_by,omitempty"`

	// A set of terms for this condition. Max 2 terms allowed - at least one 1 critical term and 1 optional warning term.
	// +kubebuilder:validation:Optional
	Term []TermParameters `json:"term,omitempty" tf:"term,omitempty"`

	// The type of NRQL alert condition to create. Valid values are: 'static', 'baseline'.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Values are: 'single_value' (deprecated) or 'sum' (deprecated)
	// +kubebuilder:validation:Optional
	ValueFunction *string `json:"valueFunction,omitempty" tf:"value_function,omitempty"`

	// Sets a time limit, in hours, that will automatically force-close a long-lasting violation after the time limit you select. Possible values are 'ONE_HOUR', 'TWO_HOURS', 'FOUR_HOURS', 'EIGHT_HOURS', 'TWELVE_HOURS', 'TWENTY_FOUR_HOURS', 'THIRTY_DAYS' (case insensitive).
	// +kubebuilder:validation:Optional
	ViolationTimeLimit *string `json:"violationTimeLimit,omitempty" tf:"violation_time_limit,omitempty"`

	// Sets a time limit, in seconds, that will automatically force-close a long-lasting violation after the time limit you select.  Must be in the range of 300 to 2592000 (inclusive)
	// +kubebuilder:validation:Optional
	ViolationTimeLimitSeconds *float64 `json:"violationTimeLimitSeconds,omitempty" tf:"violation_time_limit_seconds,omitempty"`

	// A condition term with priority set to warning.
	// +kubebuilder:validation:Optional
	Warning []WarningParameters `json:"warning,omitempty" tf:"warning,omitempty"`
}

type CriticalObservation struct {
}

type CriticalParameters struct {

	// In minutes, must be in the range of 1 to 120 (inclusive).
	// +kubebuilder:validation:Optional
	Duration *float64 `json:"duration,omitempty" tf:"duration,omitempty"`

	// One of (above, above_or_equals, below, below_or_equals, equals, not_equals). Defaults to 'equals'.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// For baseline conditions must be in range [1, 1000].
	// +kubebuilder:validation:Required
	Threshold *float64 `json:"threshold" tf:"threshold,omitempty"`

	// The duration, in seconds, that the threshold must violate in order to create a violation. Value must be a multiple of the 'aggregation_window' (which has a default of 60 seconds). Value must be within 120-3600 seconds for baseline conditions, within 120-7200 seconds for static conditions with the sum value function, and within 60-7200 seconds for static conditions with the single_value value function.
	// +kubebuilder:validation:Optional
	ThresholdDuration *float64 `json:"thresholdDuration,omitempty" tf:"threshold_duration,omitempty"`

	// The criteria for how many data points must be in violation for the specified threshold duration. Valid values are: 'ALL' or 'AT_LEAST_ONCE' (case insensitive).
	// +kubebuilder:validation:Optional
	ThresholdOccurrences *string `json:"thresholdOccurrences,omitempty" tf:"threshold_occurrences,omitempty"`

	// Valid values are: 'all' or 'any'
	// +kubebuilder:validation:Optional
	TimeFunction *string `json:"timeFunction,omitempty" tf:"time_function,omitempty"`
}

type NrqlObservation struct {
}

type NrqlParameters struct {

	// NRQL queries are evaluated in one-minute time windows. The start time depends on the value you provide in the NRQL condition's `evaluation_offset`.
	// +kubebuilder:validation:Optional
	EvaluationOffset *float64 `json:"evaluationOffset,omitempty" tf:"evaluation_offset,omitempty"`

	// +kubebuilder:validation:Required
	Query *string `json:"query" tf:"query,omitempty"`

	// NRQL queries are evaluated in one-minute time windows. The start time depends on the value you provide in the NRQL condition's `since_value`.
	// +kubebuilder:validation:Optional
	SinceValue *string `json:"sinceValue,omitempty" tf:"since_value,omitempty"`
}

type TermObservation struct {
}

type TermParameters struct {

	// In minutes, must be in the range of 1 to 120 (inclusive).
	// +kubebuilder:validation:Optional
	Duration *float64 `json:"duration,omitempty" tf:"duration,omitempty"`

	// One of (above, above_or_equals, below, below_or_equals, equals, not_equals). Defaults to 'equals'.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// One of (critical, warning). Defaults to 'critical'. At least one condition term must have priority set to 'critical'.
	// +kubebuilder:validation:Optional
	Priority *string `json:"priority,omitempty" tf:"priority,omitempty"`

	// For baseline conditions must be in range [1, 1000].
	// +kubebuilder:validation:Required
	Threshold *float64 `json:"threshold" tf:"threshold,omitempty"`

	// The duration, in seconds, that the threshold must violate in order to create a violation. Value must be a multiple of the 'aggregation_window' (which has a default of 60 seconds). Value must be within 120-3600 seconds for baseline conditions, within 120-7200 seconds for static conditions with the sum value function, and within 60-7200 seconds for static conditions with the single_value value function.
	// +kubebuilder:validation:Optional
	ThresholdDuration *float64 `json:"thresholdDuration,omitempty" tf:"threshold_duration,omitempty"`

	// The criteria for how many data points must be in violation for the specified threshold duration. Valid values are: 'ALL' or 'AT_LEAST_ONCE' (case insensitive).
	// +kubebuilder:validation:Optional
	ThresholdOccurrences *string `json:"thresholdOccurrences,omitempty" tf:"threshold_occurrences,omitempty"`

	// Valid values are: 'all' or 'any'
	// +kubebuilder:validation:Optional
	TimeFunction *string `json:"timeFunction,omitempty" tf:"time_function,omitempty"`
}

type WarningObservation struct {
}

type WarningParameters struct {

	// In minutes, must be in the range of 1 to 120 (inclusive).
	// +kubebuilder:validation:Optional
	Duration *float64 `json:"duration,omitempty" tf:"duration,omitempty"`

	// One of (above, above_or_equals, below, below_or_equals, equals, not_equals). Defaults to 'equals'.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// For baseline conditions must be in range [1, 1000].
	// +kubebuilder:validation:Required
	Threshold *float64 `json:"threshold" tf:"threshold,omitempty"`

	// The duration, in seconds, that the threshold must violate in order to create a violation. Value must be a multiple of the 'aggregation_window' (which has a default of 60 seconds). Value must be within 120-3600 seconds for baseline conditions, within 120-7200 seconds for static conditions with the sum value function, and within 60-7200 seconds for static conditions with the single_value value function.
	// +kubebuilder:validation:Optional
	ThresholdDuration *float64 `json:"thresholdDuration,omitempty" tf:"threshold_duration,omitempty"`

	// The criteria for how many data points must be in violation for the specified threshold duration. Valid values are: 'ALL' or 'AT_LEAST_ONCE' (case insensitive).
	// +kubebuilder:validation:Optional
	ThresholdOccurrences *string `json:"thresholdOccurrences,omitempty" tf:"threshold_occurrences,omitempty"`

	// Valid values are: 'all' or 'any'
	// +kubebuilder:validation:Optional
	TimeFunction *string `json:"timeFunction,omitempty" tf:"time_function,omitempty"`
}

// AlertConditionSpec defines the desired state of AlertCondition
type AlertConditionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AlertConditionParameters `json:"forProvider"`
}

// AlertConditionStatus defines the observed state of AlertCondition.
type AlertConditionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AlertConditionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AlertCondition is the Schema for the AlertConditions API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,newrelic}
type AlertCondition struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AlertConditionSpec   `json:"spec"`
	Status            AlertConditionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AlertConditionList contains a list of AlertConditions
type AlertConditionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AlertCondition `json:"items"`
}

// Repository type metadata.
var (
	AlertCondition_Kind             = "AlertCondition"
	AlertCondition_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AlertCondition_Kind}.String()
	AlertCondition_KindAPIVersion   = AlertCondition_Kind + "." + CRDGroupVersion.String()
	AlertCondition_GroupVersionKind = CRDGroupVersion.WithKind(AlertCondition_Kind)
)

func init() {
	SchemeBuilder.Register(&AlertCondition{}, &AlertConditionList{})
}
